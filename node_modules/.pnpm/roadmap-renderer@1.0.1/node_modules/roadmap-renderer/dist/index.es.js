function b(o) {
  return (o || "").replace(/^\d+-/, "");
}
function R(o) {
  let e = o >> 16 & 255, t = o >> 8 & 255, r = o & 255;
  return `rgb(${e},${t},${r})`;
}
function d(o, e = {}, t) {
  let r = document.createElementNS("http://www.w3.org/2000/svg", o);
  for (let a in e)
    !e.hasOwnProperty(a) || r.setAttribute(a, e[a]);
  return t && t.appendChild(r), r;
}
const u = 2.7, C = 4, D = 2, k = {
  black: ["#000"],
  gray: ["#000", "#333", "#666", "#999", "#ccc", "#ddd", "#eee"],
  white: ["#fff"],
  red: ["#cf2a27", "#ea9999", "#eo6666", "#cc0000", "#990000", "#660000"],
  orange: ["#ff9900", "#f9cb9c", "#f6b26b", "#e69138", "#b45f06", "#783f04"],
  yellow: ["#ffff00", "#ffe599", "#ffd966", "#f1c232", "#bf9000", "#7f6000"],
  green: ["#009e0f", "#b6d7a8", "#93c47d", "#6aa84f", "#38761d", "#274e13"],
  cyan: ["#00ffff", "#a2c4c9", "#76a5af", "#45818e", "#134f5c", "#0c343d"],
  blue: ["#2b78e4", "#9fc5f8", "#6fa8dc", "#597eaa", "#085394", "#073763"],
  purple: ["#9900ff", "#b4a7d6", "#8e7cc3", "#674ea7", "#351c75", "#20124d"],
  pink: ["#ff00ff", "#d5a6bd", "#c27ba0", "#a64d79", "#741b47", "#4c1130"]
};
class v {
  constructor(e, t) {
    this.svgRoot = e, this.fontFamily = t, this.canvasRenderingContext2D = document.createElement("canvas").getContext("2d");
  }
  render(e, t) {
    let r = e.typeID;
    r in this ? this[r](e, t) : console.log(`'${r}' control type not implemented`);
  }
  parseColor(e, t) {
    return e === void 0 ? `rgb(${t})` : R(e);
  }
  parseFontProperties(e) {
    var t, r, a;
    return {
      style: (t = e.properties) != null && t.italic ? "italic" : "normal",
      weight: (r = e.properties) != null && r.bold ? "bold" : "normal",
      size: (a = e.properties) != null && a.size ? e.properties.size + "px" : "13px",
      family: this.fontFamily
    };
  }
  measureText(e, t) {
    return this.canvasRenderingContext2D.font = t, this.canvasRenderingContext2D.measureText(e);
  }
  drawRectangle(e, t) {
    var r, a, s, n, p, i;
    d(
      "rect",
      {
        x: parseInt(e.x) + u / 2,
        y: parseInt(e.y) + u / 2,
        width: parseInt((r = e.w) != null ? r : e.measuredW) - u,
        height: parseInt((a = e.h) != null ? a : e.measuredH) - u,
        rx: D,
        fill: this.parseColor((s = e.properties) == null ? void 0 : s.color, "255,255,255"),
        "fill-opacity": (p = (n = e.properties) == null ? void 0 : n.backgroundAlpha) != null ? p : 1,
        stroke: this.parseColor((i = e.properties) == null ? void 0 : i.borderColor, "0,0,0"),
        "stroke-width": u
      },
      t
    );
  }
  addText(e, t, r, a) {
    var y, g;
    let s = (y = e.properties.text) != null ? y : "", n = parseInt(e.x), p = parseInt(e.y), i = this.parseFontProperties(e), l = this.measureText(
      s,
      `${i.style} ${i.weight} ${i.size} ${i.family}`
    ), c = a === "center" ? n + ((g = e.w) != null ? g : e.measuredW) / 2 - l.width / 2 : n, m = p + e.measuredH / 2 + l.actualBoundingBoxAscent / 2, x = d(
      "text",
      {
        x: c,
        y: m,
        fill: r,
        "font-style": i.style,
        "font-weight": i.weight,
        "font-size": i.size
      },
      t
    );
    if (!s.includes("{color:")) {
      let h = d("tspan", {}, x);
      h.textContent = s;
      return;
    }
    s.split(/{color:|{color}/).forEach((h) => {
      if (h.includes("}")) {
        let [f, I] = h.split("}");
        if (!f.startsWith("#")) {
          let w = parseInt(f.slice(-1));
          f = isNaN(w) ? k[f][0] : k[f][w];
        }
        let $ = d("tspan", { fill: f }, x);
        $.textContent = I;
      } else {
        let f = d("tspan", {}, x);
        f.textContent = h;
      }
    });
  }
  TextArea(e, t) {
    this.drawRectangle(e, t);
  }
  Canvas(e, t) {
    this.drawRectangle(e, t);
  }
  Label(e, t) {
    var r;
    this.addText(
      e,
      t,
      this.parseColor((r = e.properties) == null ? void 0 : r.color, "0,0,0"),
      "left"
    );
  }
  TextInput(e, t) {
    var r;
    this.drawRectangle(e, t), this.addText(
      e,
      t,
      this.parseColor((r = e.properties) == null ? void 0 : r.textColor, "0,0,0"),
      "center"
    );
  }
  Arrow(e, t) {
    var c, m, x;
    let r = parseInt(e.x), a = parseInt(e.y), { p0: s, p1: n, p2: p } = e.properties, i;
    ((c = e.properties) == null ? void 0 : c.stroke) === "dotted" ? i = "0.8 12" : ((m = e.properties) == null ? void 0 : m.stroke) === "dashed" && (i = "28 46");
    let l = { x: (p.x - s.x) * n.x, y: (p.y - s.y) * n.x };
    d(
      "path",
      {
        d: `M${r + s.x} ${a + s.y}Q${r + s.x + l.x + l.y * n.y * 3.6} ${a + s.y + l.y + -l.x * n.y * 3.6} ${r + p.x} ${a + p.y}`,
        fill: "none",
        stroke: this.parseColor((x = e.properties) == null ? void 0 : x.color, "0,0,0"),
        "stroke-width": C,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-dasharray": i
      },
      t
    );
  }
  Icon(e, t) {
    var n;
    let r = parseInt(e.x), a = parseInt(e.y), s = 10;
    d(
      "circle",
      {
        cx: r + s,
        cy: a + s,
        r: s,
        fill: this.parseColor((n = e.properties) == null ? void 0 : n.color, "0,0,0")
      },
      t
    ), e.properties.icon.ID === "check-circle" && d(
      "path",
      {
        d: `M${r + 4.5} ${a + s}L${r + 8.5} ${a + s + 4} ${r + 15} ${a + s - 2.5}`,
        fill: "none",
        stroke: "#fff",
        "stroke-width": 3.5,
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      t
    );
  }
  HRule(e, t) {
    var n, p, i, l;
    let r = parseInt(e.x), a = parseInt(e.y), s;
    ((n = e.properties) == null ? void 0 : n.stroke) === "dotted" ? s = "0.8, 8" : ((p = e.properties) == null ? void 0 : p.stroke) === "dashed" && (s = "18, 30"), d(
      "path",
      {
        d: `M${r} ${a}L${r + parseInt((i = e.w) != null ? i : e.measuredW)} ${a}`,
        fill: "none",
        stroke: this.parseColor((l = e.properties) == null ? void 0 : l.color, "0,0,0"),
        "stroke-width": u,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-dasharray": s
      },
      t
    );
  }
  __group__(e, t) {
    var p;
    const r = (p = e == null ? void 0 : e.properties) == null ? void 0 : p.controlName, a = b(r), s = localStorage.getItem(a) === "done";
    let n = d(
      "g",
      {
        ...r ? {
          class: `clickable-group ${s ? "done" : ""}`,
          "data-group-id": r
        } : {}
      },
      t
    );
    e.children.controls.control.sort((i, l) => i.zOrder - l.zOrder).forEach((i) => {
      i.x = parseInt(i.x, 10) + parseInt(e.x, 10), i.y = parseInt(i.y, 10) + parseInt(e.y, 10), this.render(i, n);
    });
  }
}
async function z(o, e = {}) {
  if (e = {
    padding: 5,
    fontFamily: "balsamiq",
    fontURL: "https://fonts.gstatic.com/s/balsamiqsans/v3/P5sEzZiAbNrN8SB3lQQX7Pncwd4XIA.woff2",
    ...e
  }, e.fontURL) {
    let l = new FontFace(e.fontFamily, `url(${e.fontURL})`);
    await l.load(), document.fonts.add && document.fonts.add(l);
  }
  let t = o.mockup, r = t.measuredW - t.mockupW - e.padding, a = t.measuredH - t.mockupH - e.padding, s = parseInt(t.mockupW) + e.padding * 2, n = parseInt(t.mockupH) + e.padding * 2, p = d("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: `${r} ${a} ${s} ${n}`,
    style: "font-family: balsamiq"
  }), i = new v(p, e.fontFamily);
  return t.controls.control.sort((l, c) => l.zOrder - c.zOrder).forEach((l) => {
    i.render(l, p);
  }), p;
}
export {
  z as wireframeJSONToSVG
};
